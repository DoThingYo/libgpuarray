
# This file is generated by gen_blas.py in the root of the distribution
from pygpu.gpuarray import GpuArrayException
from pygpu.gpuarray cimport (_GpuArray, GpuArray, GA_NO_ERROR, GpuArray_error,
                             pygpu_copy, pygpu_empty, GA_ANY_ORDER, GA_F_ORDER,
                             GpuArray_ISONESEGMENT)

cdef extern from "compyte/buffer_blas.h":
    ctypedef enum cb_transpose:
        cb_no_trans,
        cb_trans,
        cb_conj_trans

cdef extern from "compyte/blas.h":
    int GpuArray_rgemv(const cb_transpose transA, const double alpha, _GpuArray *A, _GpuArray *X, const double beta, _GpuArray *Y,
                             int nocopy)

cdef blas_rgemv(const cb_transpose transA, const double alpha, GpuArray A, GpuArray X, const double beta, GpuArray Y,
                      bint nocopy):
    cdef int err
    err = GpuArray_rgemv(transA, alpha, &A.ga, &X.ga, beta, &Y.ga, nocopy);
    if err != GA_NO_ERROR:
        raise GpuArrayException(GpuArray_error(&A.ga, err), err)

cdef api GpuArray pygpu_blas_rgemv(const cb_transpose transA, const double alpha, GpuArray A, GpuArray X, const double beta, GpuArray Y):
    blas_rgemv(transA, alpha, A, X, beta, Y, 0)

    return Y

def gemv(double alpha, GpuArray A, GpuArray X, double beta=0.0, GpuArray Y=None, trans_a=False, overwrite_y=False):
    cdef cb_transpose transA
    cdef size_t Yshp

    if trans_a:
        transA = cb_trans
    else:
        transA = cb_no_trans

    
    if A.ga.nd != 2:
        raise TypeError, "A is not a matrix"
    if transA == cb_no_trans:
        Yshp = A.ga.dimensions[0]
    else:
        Yshp = A.ga.dimensions[1]
    if Y is None:
        if beta != 0.0:
            raise ValueError, "Y not provided and beta != 0"
        Y = pygpu_empty(1, &Yshp, A.ga.typecode, GA_ANY_ORDER, A.context, None)
        overwrite_y = True


    if not overwrite_y:
        Y = pygpu_copy(Y, GA_ANY_ORDER)
    return pygpu_blas_rgemv(transA, alpha, A, X, beta, Y)
